<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bouncing Ball Trefoil</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body onload="spiral()">
<canvas id="canvas"></canvas>

<script>
// Get canvas and context
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');



// Resize canvas to fill window
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const center = [canvas.width/2, canvas.height/2];
const slength =  500;

const apex = [center[0], center[1]-(1/Math.sqrt(3))*slength];
const bleft = [center[0]-slength/2, center[1]+(1/(2*Math.sqrt(3)))*slength];
const bright = [center[0]+slength/2, center[1]+(1/(2*Math.sqrt(3)))*slength];
var imgData=ctx.createImageData(660, 660);


var pathArrR=[];
var pathArrG=[];
var pathArrB=[];
var pathArrY=[];
var pathArr=[];

// Ball properties

function Ball(x, y, radius, pathindx, color) {
    this.x = null;
    this.y = null;
    this.radius = 20;
    this.pathindx = 0;
    this.color = "rgb(255,255,255)";
}

let ball1 = new Ball();

let ball2 = new Ball();

let ball3 = new Ball();

let ball4 = new Ball();

// Function to generate random bright colors
function getRandomColor() {
    const r = Math.floor(Math.random() * 200) + 55;
    const g = Math.floor(Math.random() * 200) + 55;
    const b = Math.floor(Math.random() * 200) + 55;
    return `rgb(${r},${g},${b})`;
}

// Draw the ball
function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.closePath();
}

function equilateral() {
      ctx.lineWidth = 1;
      
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(bleft[0],bleft[1]);
      ctx.quadraticCurveTo(apex[0], apex[1]+(1/12)*slength, bright[0], bright[1]);
      ctx.stroke();

      ctx.strokeStyle = "green";
      ctx.beginPath();
      ctx.moveTo(bright[0],bright[1]);
      ctx.quadraticCurveTo(bleft[0]+(1/18)*slength, bleft[1]-(1/36)*slength, apex[0], apex[1]);
      ctx.stroke();

      ctx.strokeStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(apex[0],apex[1]);
      ctx.quadraticCurveTo(bright[0]-(1/18)*slength, bright[1]-(1/36)*slength, bleft[0], bleft[1]);
      ctx.stroke();

      imgData = ctx.getImageData(bleft[0], apex[1], bright[0], bright[1]);
      
      getpathArr();
      
    }

function circle() {
    ctx.fillStyle = 'rgba(0, 0, 0, 1)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.arc(center[0], center[1], slength/3, 0, 2 * Math.PI);
    ctx.stroke();

    imgData = ctx.getImageData(center[0]-slength/3, center[1]-slength/3, center[0]+slength/3, center[1]+slength/3);
    getCircleArr();
}

function sailor() {

    
    boxes=10;
    halfbox=50;
    start=[center[0]-2*boxes*halfbox, center[1]];

    ctx.strokeStyle = "red";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]-2*halfbox);
    lastposn=[start[0]+halfbox,start[1]-2*halfbox];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }
    ctx.lineTo(nextposn[0],nextposn[1]);
    ctx.stroke();

    ctx.strokeStyle = "green";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]-2*halfbox);
    lastposn=[start[0],start[1]-halfbox];
    nextposn=[lastposn[0]+halfbox, lastposn[1]+halfbox];
    ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
    lastposn=[nextposn[0],nextposn[1]];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }
    ctx.lineTo(nextposn[0],nextposn[1]);
    ctx.stroke();

    ctx.strokeStyle = "blue";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]);
    lastposn=[start[0],start[1]];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }

    ctx.arcTo(nextposn[0],nextposn[1],nextposn[0]+halfbox,nextposn[1],20);
    ctx.lineTo(nextposn[0]+halfbox,nextposn[1]);
    ctx.stroke();

    imgData = ctx.getImageData(start[0], start[1]-2*halfbox, start[0]+boxes*4*halfbox+halfbox, start[1]);
    getSailorPathArr(start, boxes, halfbox);

}

function solomon() {
    quartersize = 300;
    trackwidth = 60;

    start=[center[0]-quartersize, center[1]+quartersize/2];

    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.moveTo(start[0],start[1]);
    nextposn = [start[0], start[1]-quartersize];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0]+2*quartersize,nextposn[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0], nextposn[1]+quartersize];
    ctx.lineTo(nextposn[0], nextposn[1]);
    ctx.lineTo(start[0], start[1]);
    ctx.stroke();


    ctx.strokeStyle = "green";
    ctx.beginPath();
    ctx.moveTo(start[0]+trackwidth,start[1]-trackwidth);
    nextposn = [start[0]+trackwidth, start[1]-quartersize+trackwidth];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0]+2*quartersize-2*trackwidth,nextposn[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0], nextposn[1]+quartersize-2*trackwidth];
    ctx.lineTo(nextposn[0], nextposn[1]);
    ctx.lineTo(start[0]+trackwidth, start[1]-trackwidth);
    ctx.stroke();

    start=[center[0]-quartersize/2, center[1]-quartersize];

    ctx.strokeStyle = "blue";
    ctx.beginPath();
    ctx.moveTo(start[0],start[1]);
    nextposn = [start[0]+quartersize, start[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0],nextposn[1]+2*quartersize];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0]-quartersize, nextposn[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);
    ctx.lineTo(start[0], start[1]);
    ctx.stroke();

    ctx.strokeStyle = "yellow";
    ctx.beginPath();
    ctx.moveTo(start[0]+trackwidth,start[1]+trackwidth);
    nextposn = [start[0]+quartersize-trackwidth, start[1]+trackwidth];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0],nextposn[1]+2*quartersize-2*trackwidth];
    ctx.lineTo(nextposn[0], nextposn[1]);
    nextposn = [nextposn[0]-quartersize+2*trackwidth, nextposn[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);
    ctx.lineTo(start[0]+trackwidth, start[1]+trackwidth);

    ctx.stroke();
    imgData = ctx.getImageData(center[0]-quartersize, center[1]-quartersize, 2*quartersize+trackwidth, 2*quartersize+trackwidth);
    getSolomonArr(quartersize, trackwidth);
    
}

function dara() {
    quartersize = 300;

    start=[center[0]-quartersize/10-quartersize, center[1]-quartersize/10];

    ctx.strokeStyle = "red";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]);
    ctrlposn = [start[0],start[1]-quartersize/2];

    nextposn = [start[0]+quartersize, start[1]-quartersize/2];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);
    ctx.lineTo(nextposn[0]+quartersize/5, nextposn[1]);
    nextposn = [center[0]+quartersize/10+quartersize, center[1]-quartersize/10];
    ctrlposn = [nextposn[0], nextposn[1]-quartersize/2];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);


    getDaraArr(quartersize, "l_r");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [center[0]+quartersize/10, center[1]-quartersize/10];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "r_l");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [nextposn[0], nextposn[1]-quartersize];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "d_u");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    ctrlposn = [nextposn[0]+quartersize/2, nextposn[1]];
    nextposn = [nextposn[0]+quartersize/2, nextposn[1]+quartersize];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);
    ctx.lineTo(nextposn[0],nextposn[1]+quartersize/5);
    ctrlposn = [nextposn[0], nextposn[1]+quartersize/5+quartersize];
    nextposn = [center[0]+quartersize/10, center[1]+quartersize/10+quartersize];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "u_d");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [center[0]+quartersize/10, center[1]+quartersize/10];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "d_u");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [nextposn[0]+quartersize, nextposn[1]];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "l_r");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    ctrlposn = [nextposn[0], nextposn[1]+quartersize/2];
    nextposn = [nextposn[0]-quartersize, nextposn[1]+quartersize/2];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);
    ctx.lineTo(nextposn[0]-quartersize/5, nextposn[1]);
    ctrlposn = [nextposn[0]-quartersize/5-quartersize, nextposn[1]];
    nextposn = [center[0]-quartersize/10-quartersize, center[1]+quartersize/10];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "r_l");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [center[0]-quartersize/10, center[1]+quartersize/10];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "l_r");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [nextposn[0], nextposn[1]+quartersize];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "u_d");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    ctrlposn = [nextposn[0]-quartersize/2, nextposn[1]];
    nextposn = [nextposn[0]-quartersize/2, nextposn[1]-quartersize];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);
    nextposn = [nextposn[0], nextposn[1]-quartersize/5];
    ctx.lineTo(nextposn[0], nextposn[1]);
    ctrlposn = [nextposn[0], nextposn[1]-quartersize];
    nextposn = [nextposn[0]+quartersize/2,nextposn[1]-quartersize ];
    ctx.quadraticCurveTo(ctrlposn[0], ctrlposn[1], nextposn[0],nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "d_u");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    nextposn = [center[0]-quartersize/10, center[1]-quartersize/10];
    ctx.lineTo(nextposn[0], nextposn[1]);

    ctx.stroke();
    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "u_d");

    ctx.beginPath();
    ctx.moveTo(nextposn[0],nextposn[1]);

    ctx.lineTo(start[0], start[1]);
    ctx.stroke();

    imgData = ctx.getImageData(start[0], start[1]-quartersize, quartersize*2.2, quartersize*2.2);
    getDaraArr(quartersize, "r_l");


}

function spiral()  {
    quartersize = 300;
    a = 9.5;
    r = 0;
    pathArrR=[];
    pathArrB=[];
    pathArrG=[];

    ctx.lineWidth = 10;
    ctx.strokeStyle = "red";
    ctx.beginPath();

    ctx.moveTo(center[0],center[1]+quartersize/2);
    pathArrR=[[center[0],center[1]+quartersize/2]];

    for (theta=0; theta<=5*Math.PI+0.045; theta=theta+0.05) {
        r = a * theta;
        x = center[0] + r * Math.sin(theta);
        y = center[1]+quartersize/2 + r * Math.cos(theta);
        ctx.lineTo(x,y);
        pathArrR.push([x,y]);
    }
    ctx.stroke();

    ctx.beginPath();

    ctx.moveTo(center[0],center[1]-quartersize/2);
    pathArrB=[[center[0],center[1]-quartersize/2]];

    for (theta=0; theta<=5.25*Math.PI+0.045; theta=theta+0.05) {
        r = a * theta;
        x = center[0] + r * Math.sin(theta+Math.PI);
        y = center[1]-quartersize/2 + r * Math.cos(theta+Math.PI);
        ctx.lineTo(x,y);
        pathArrB.push([x,y]);
    }
    ctx.stroke();

    ctx.beginPath();

    ctx.moveTo(center[0]+Math.sqrt(3)*quartersize/2-5,center[1]);
    pathArrG=[[center[0]+Math.sqrt(3)*quartersize/2-5,center[1]]];

    for (theta=0; theta<=5.15*Math.PI+0.045; theta=theta+0.05) {
        r = a * theta;
        x = center[0]+Math.sqrt(3)*quartersize/2-5 + r * Math.sin(theta+Math.PI/2);
        y = center[1] + r * Math.cos(theta+Math.PI/2);
        ctx.lineTo(x,y);
        pathArrG.push([x,y]);
    }
    ctx.stroke();

    pathArrR_rev = pathArrR.toReversed();
    pathArrB_rev = pathArrB.toReversed();
    pathArrG_rev = pathArrG.toReversed();

    let R_to_B_rev_indx = pathArrB_rev.reduce(bestIndxRB, 0);

    function bestIndxRB(total, value, index, array)  {
        if (Math.abs(pathArrR_rev[0][0]-value[0])+Math.abs(pathArrR_rev[0][1]-value[1])<Math.abs(pathArrR_rev[0][0]-pathArrB_rev[total][0])+Math.abs(pathArrR_rev[0][1]-pathArrB_rev[total][1])) {
            total = index;
        }
        return total;
    }
    let B_to_G_rev_indx = pathArrG_rev.reduce(bestIndxBG, 0);

    function bestIndxBG(total, value, index, array)  {
        if (Math.abs(pathArrB_rev[0][0]-value[0])+Math.abs(pathArrB_rev[0][1]-value[1])<Math.abs(pathArrB_rev[0][0]-pathArrG_rev[total][0])+Math.abs(pathArrB_rev[0][1]-pathArrG_rev[total][1])) {
            total = index;
        }
        return total;
    }
    let G_to_R_rev_indx = pathArrR_rev.reduce(bestIndxGR, 0);

    function bestIndxGR(total, value, index, array)  {
        if (Math.abs(pathArrG_rev[0][0]-value[0])+Math.abs(pathArrG_rev[0][1]-value[1])<Math.abs(pathArrG_rev[0][0]-pathArrR_rev[total][0])+Math.abs(pathArrG_rev[0][1]-pathArrR_rev[total][1])) {
            total = index;
        }
        return total;
    }

    pathArr = pathArrR.concat(pathArrB_rev.slice(R_to_B_rev_indx)).concat(pathArrB.concat(pathArrG_rev.slice(B_to_G_rev_indx))).concat(pathArrG.concat(pathArrR_rev.slice(G_to_R_rev_indx)));


}

function getSolomonArr(quartersize, trackwidth) {
    pathArrR = [];
    pathArrG = [];
    pathArrB = [];
    pathArrY = [];
    start1 = [parseInt(center[0]-quartersize), parseInt(center[1]-quartersize)];
    start2 = [parseInt(center[0]-quartersize+trackwidth), parseInt(center[1])];

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%4==0 && imgData.data[i1+1]==0) {
                pathArrR.push([start1[0]+Math.floor(i1/4)%(imgData.width), 
                start1[1]+Math.floor((i1/4)/(imgData.width))]);
            } else if (i1%4==1 && imgData.data[i1-1]==0) {
                pathArrG.push([start1[0]+Math.floor(i1/4)%(imgData.width), 
                start1[1]+Math.floor((i1/4)/(imgData.width))]);
            } else if (i1%4==2) {
                pathArrB.push([start1[0]+Math.floor(i1/4)%(imgData.width), 
                start1[1]+Math.floor((i1/4)/(imgData.width))]);
            } else if (i1%4==0 && imgData.data[i1+1]!=0) {
                pathArrY.push([start1[0]+Math.floor(i1/4)%(imgData.width), 
                start1[1]+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }

    function quartersort(a, b) {
        if (a[0]<=center[0] && a[1]<=center[1] ) {
            QA = 1;
        }
        if (a[0]>=center[0] && a[1]<=center[1] ) {
            QA = 2;
        }
        if (a[0]>=center[0] && a[1]>=center[1] ) {
            QA = 3;
        }
        if (a[0]<=center[0] && a[1]>=center[1] ) {
            QA = 4;
        }
        if (b[0]<=center[0] && b[1]<=center[1] ) {
            QB = 1;
        }
        if (b[0]>=center[0] && b[1]<=center[1] ) {
            QB = 2;
        }
        if (b[0]>=center[0] && b[1]>=center[1] ) {
            QB = 3;
        }
        if (b[0]<=center[0] && b[1]>=center[1] ) {
            QB = 4;
        }
        return QA-QB;
    }


    pathArrR.sort(quartersort);
    pathArrB.sort(quartersort);
    pathArrY.sort(quartersort);


    pathArrR.sort(function(a, b){if(a[0]!=b[0] && a[1]<center[1]) {return a[0] - b[0]} 
    else if(a[0]!=b[0] && a[1]>center[1]) {return b[0] - a[0]} else if(a[0]==b[0] && a[0]<center[0]) {return b[1] - a[1]}
    else if(a[0]==b[0] && a[0]>center[0]) {return a[1] - b[1]} });

    pathArrB.sort(function(a, b){if(a[0]!=b[0] && a[1]<center[1]) {return a[0] - b[0]} 
    else if(a[0]!=b[0] && a[1]>center[1]) {return b[0] - a[0]} else if(a[0]==b[0] && a[0]<center[0]) {return b[1] - a[1]}
    else if(a[0]==b[0] && a[0]>center[0]) {return a[1] - b[1]} });

    pathArrG.sort(function(a){if (a[0]>center[0] && a[1]>center[1]) {return 1} else if (a[0]>center[0] && a[1]<center[1]) {return -1} else {return 0}});

    pathArrG.sort(function(a, b){if(a[0]!=b[0] && a[1]<center[1]) {return b[0] - a[0]} 
    else if(a[0]!=b[0] && a[1]>center[1]) {return a[0] - b[0]} else if(a[0]==b[0] && a[0]<center[0]) {return a[1] - b[1]}
    else if(a[0]==b[0] && a[0]>center[0]) {return b[1] - a[1]} });

    pathArrY.sort(function(a){if (a[0]>center[0] && a[1]>center[1]) {return 1} else if (a[0]>center[0] && a[1]<center[1]) {return -1} else {return 0}});

    pathArrY.sort(function(a, b){if(a[0]!=b[0] && a[1]<center[1]) {return b[0] - a[0]} 
    else if(a[0]!=b[0] && a[1]>center[1]) {return a[0] - b[0]} else if(a[0]==b[0] && a[0]<center[0]) {return a[1] - b[1]}
    else if(a[0]==b[0] && a[0]>center[0]) {return b[1] - a[1]} });



    function sieveR(currentValue, index, arr) {
        if (index%4==0) {
            if (index<=5*arr.length/14) {
                return currentValue;
            }
            if (index>=6*arr.length/14 && index<=8*arr.length/14) {
                return currentValue;
            }
            if (index>=9*arr.length/14) {
                return currentValue;
            }
        }
    }
    function sieveG(currentValue, index, arr) {
        if (index%2==0) {
            if (index>=arr.length/16 && index<=6.3*arr.length/16) {
                return currentValue;
            } 
            else 
            if (index>=7.2*arr.length/16 && index<=8.85*arr.length/16) {
                return currentValue;
            } else 
            if (index>=9.8*arr.length/16 && index<=15.1*arr.length/16) {
                return currentValue;
            } 
            
        }

    }

    function sieveB(currentValue, index, arr) {
        if (index%4==0) {
            if (index>=arr.length/10  && index<=4*arr.length/10) {
                return currentValue;
            }   
            if (index>=5*arr.length/10  && index<6*arr.length/10 )  {
                return currentValue;
            }  
            if (index>=7*arr.length/10  && index<9*arr.length/10 )  {
                return currentValue;
            }         
        }

    }
    function sieveY(currentValue, index, arr) {
        if (index%2==0) {
            if (index>=1.1*arr.length/10  && index<=3.9*arr.length/10) {
                return currentValue;
            }   
            if (index>=5*arr.length/10  && index<6*arr.length/10 )  {
                return currentValue;
            }  
            if (index>=7*arr.length/10  && index<8.93*arr.length/10 )  {
                return currentValue;
            }         
        }

    }
    pathArrR=pathArrR.filter(sieveR);
    pathArrR.shift();
    pathArrG=pathArrG.filter(sieveG);
    pathArrB=pathArrB.filter(sieveB);
    pathArrB.shift();
    pathArrY=pathArrY.filter(sieveY);



}

function getDaraArr(quartersize, dirn) {
    
    pathArrR = [];
    start1=[center[0]-quartersize/10-quartersize, center[1]-quartersize/10-quartersize];

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%4==0) {
                pathArrR.push([start1[0]+(i1/4)%(imgData.width), 
                start1[1]+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }
    if (dirn=="l_r") {
        pathArrR.sort(function(a, b){return a[0] - b[0]});
    } else if (dirn=="r_l") {
        pathArrR.sort(function(a, b){return b[0] - a[0]});
    } else if (dirn=="d_u") {
        pathArrR.sort(function(a, b){return b[1] - a[1]});
    } else if (dirn=="u_d") {
        pathArrR.sort(function(a, b){return a[1] - b[1]});
    } 



    function sieve(currentValue, index, arr) {
        if (index%4==0) {
            return currentValue;
        }
    }

    pathArrR_f=pathArrR.filter(sieve);
    
    pathArr = pathArr.concat(Array.from(pathArrR_f));

    ctx.fillStyle = 'rgba(0, 0, 0, 1)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

}

function getCircleArr() {
    pathArrY=[];
    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%16==0 ) {
                pathArrY.push([center[0]-slength/3+(i1/4)%(imgData.width), 
                center[1]-slength/3+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }

    pathArrY.sort(function(a, b){if (a[1]<center[1] && b[1]<center[1]) {return a[0] - b[0]} 
        else if (a[1]<center[1] && b[1]>=center[1]) {return 1}
        else if (a[1]>center[1] && b[1]<=center[1]) {return -1}
       else  {return b[0] - a[0]} });
}

function getpathArr() {
    pathArrR=[];
    pathArrG=[];
    pathArrB=[];
    //pathArrR.push([bleft[0],bleft[1]]) ;

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%16==0) {
                pathArrR.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%16==1) {
                pathArrG.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%16==2) {
                pathArrB.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }
    pathArrR.sort(function(a, b){if (Math.abs(a[0] - b[0])>0.1) {return a[0] - b[0]} else if (a[0]<center[0]) {return a[1] - b[1]} else {return b[1] - a[1]} });
    pathArrG.sort(function(a, b){if (Math.abs(b[1] - a[1])>0.1) {return b[1] - a[1]} else {return b[0] - a[0]}});
    pathArrB.sort(function(a, b){if (Math.abs(a[1] - b[1])>0.1) {return a[1] - b[1]} else {return b[0] - a[0]}});
    
    pathArr=Array.from(pathArrR).concat(Array.from(pathArrG)).concat(Array.from(pathArrB));
    //circle();
}

function getSailorPathArr(start, boxes, halfbox) {
    pathArrR=[];
    pathArrG=[];
    pathArrB=[];
    // start=[center[0]/2, center[1]];
    // boxes=4;
    // halfbox=center[1]/(2*boxes);
    //pathArrR.push([bleft[0],bleft[1]]) ;

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%4==0) {
                pathArrR.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%4==1) {
                pathArrG.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%4==2) {
                pathArrB.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }
    pathArrR.sort(function(a, b){return a[0] - b[0]});
    pathArrG.sort(function(a, b){if (Math.abs(b[0] - a[0])>0.1) {return b[0] - a[0]} else {return b[1]-a[1]}});
    pathArrB.sort(function(a, b){return a[0] - b[0]});

    function sieve(currentValue, index, arr) {
        if (index%4==0) {
            return currentValue;
        }
    }

    pathArrR_f=pathArrR.filter(sieve);
    pathArrG_f=pathArrG.filter(sieve);
    pathArrB_f=pathArrB.filter(sieve);
    
    pathArr=Array.from(pathArrB_f).concat(Array.from(pathArrG_f)).concat(Array.from(pathArrR_f));
    //circle();



}

// Update ball position and bounce logic
function updateBall(ball, pathArr) {


    if (ball.pathindx<pathArr.length-1) {
        ball.pathindx+=1;
    } else {
        ball.pathindx=0;
        ball.color = getRandomColor();
    }
    
    ball.x = pathArr[ball.pathindx][0];
    ball.y = pathArr[ball.pathindx][1];

    // Bounce off left/right walls
    if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx *= -1;
        ball.color = getRandomColor(); // change color on bounce
    }

    // Bounce off top/bottom walls
    if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
        ball.dy *= -1;
        ball.color = getRandomColor(); // change color on bounce
    }
}

// Animation loop
function animate() {
    // Draw semi-transparent background for trailing effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawBall(ball1);
    updateBall(ball1, pathArr);
    if (ball2.x==null) {
        ball2.pathindx = parseInt(pathArr.length/3);
        ball3.pathindx = parseInt(2*pathArr.length/3);
        //ball4.pathindx = parseInt(pathArr.length*0.5+Math.random()*pathArr.length*0.5);
    }
    
    drawBall(ball2);
    updateBall(ball2, pathArr);
    
    drawBall(ball3);
    updateBall(ball3, pathArr);
    // drawBall(ball4);
    // updateBall(ball4, pathArrY);

    requestAnimationFrame(animate);

}

// Start animation
window.setTimeout(animate, 1000);


</script>
</body>
</html>

