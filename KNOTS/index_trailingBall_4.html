<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bouncing Ball Trefoil</title>
<style>
    body {
        margin: 0;
        background: black;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body onload="sailor()">
<canvas id="canvas"></canvas>

<script>
// Get canvas and context
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');



// Resize canvas to fill window
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const center = [canvas.width/2, canvas.height/2];
const slength =  500;

const apex = [center[0], center[1]-(1/Math.sqrt(3))*slength];
const bleft = [center[0]-slength/2, center[1]+(1/(2*Math.sqrt(3)))*slength];
const bright = [center[0]+slength/2, center[1]+(1/(2*Math.sqrt(3)))*slength];
var imgData=ctx.createImageData(500, 433);


var pathArrR=[];
var pathArrG=[];
var pathArrB=[];
var pathArrY=[];
var pathArr=[];

// Ball properties

function Ball(x, y, radius, pathindx, color) {
    this.x = null;
    this.y = null;
    this.radius = 20;
    this.pathindx = 0;
    this.color = "rgb(255,255,255)";
}

let ball1 = new Ball();

let ball2 = new Ball();

let ball3 = new Ball();

let ball4 = new Ball();

// Function to generate random bright colors
function getRandomColor() {
    const r = Math.floor(Math.random() * 200) + 55;
    const g = Math.floor(Math.random() * 200) + 55;
    const b = Math.floor(Math.random() * 200) + 55;
    return `rgb(${r},${g},${b})`;
}

// Draw the ball
function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.closePath();
}

function equilateral() {
      ctx.lineWidth = 1;
      
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(bleft[0],bleft[1]);
      ctx.quadraticCurveTo(apex[0], apex[1]+(1/12)*slength, bright[0], bright[1]);
      ctx.stroke();

      ctx.strokeStyle = "green";
      ctx.beginPath();
      ctx.moveTo(bright[0],bright[1]);
      ctx.quadraticCurveTo(bleft[0]+(1/18)*slength, bleft[1]-(1/36)*slength, apex[0], apex[1]);
      ctx.stroke();

      ctx.strokeStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(apex[0],apex[1]);
      ctx.quadraticCurveTo(bright[0]-(1/18)*slength, bright[1]-(1/36)*slength, bleft[0], bleft[1]);
      ctx.stroke();

      imgData = ctx.getImageData(bleft[0], apex[1], bright[0], bright[1]);
      
      getpathArr();
      
    }

function circle() {
    ctx.fillStyle = 'rgba(0, 0, 0, 1)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.arc(center[0], center[1], slength/3, 0, 2 * Math.PI);
    ctx.stroke();

    imgData = ctx.getImageData(center[0]-slength/3, center[1]-slength/3, center[0]+slength/3, center[1]+slength/3);
    getCircleArr();
}

function sailor() {

    
    boxes=10;
    halfbox=50;
    start=[center[0]-2*boxes*halfbox, center[1]];

    ctx.strokeStyle = "red";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]-2*halfbox);
    lastposn=[start[0]+halfbox,start[1]-2*halfbox];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }
    ctx.lineTo(nextposn[0],nextposn[1]);
    ctx.stroke();

    ctx.strokeStyle = "green";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]-2*halfbox);
    lastposn=[start[0],start[1]-halfbox];
    nextposn=[lastposn[0]+halfbox, lastposn[1]+halfbox];
    ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
    lastposn=[nextposn[0],nextposn[1]];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }
    ctx.lineTo(nextposn[0],nextposn[1]);
    ctx.stroke();

    ctx.strokeStyle = "blue";
    ctx.beginPath();

    ctx.moveTo(start[0],start[1]);
    lastposn=[start[0],start[1]];

    for (n1=0; n1<boxes; n1++) {
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]-2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
        nextposn=[lastposn[0]+2*halfbox, lastposn[1]+2*halfbox];
        ctx.arcTo(lastposn[0], lastposn[1], nextposn[0],nextposn[1],20);
        lastposn=[nextposn[0],nextposn[1]];
    }

    ctx.arcTo(nextposn[0],nextposn[1],nextposn[0]+halfbox,nextposn[1],20);
    ctx.lineTo(nextposn[0]+halfbox,nextposn[1]);
    ctx.stroke();

    imgData = ctx.getImageData(start[0], start[1]-2*halfbox, start[0]+boxes*4*halfbox+halfbox, start[1]);
    getSailorPathArr(start, boxes, halfbox);

}

function getCircleArr() {
    pathArrY=[];
    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%16==0 ) {
                pathArrY.push([center[0]-slength/3+(i1/4)%(imgData.width), 
                center[1]-slength/3+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }

    pathArrY.sort(function(a, b){if (a[1]<center[1] && b[1]<center[1]) {return a[0] - b[0]} 
        else if (a[1]<center[1] && b[1]>=center[1]) {return 1}
        else if (a[1]>center[1] && b[1]<=center[1]) {return -1}
       else  {return b[0] - a[0]} });
}

function getpathArr() {
    pathArrR=[];
    pathArrG=[];
    pathArrB=[];
    //pathArrR.push([bleft[0],bleft[1]]) ;

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%16==0) {
                pathArrR.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%16==1) {
                pathArrG.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%16==2) {
                pathArrB.push([bleft[0]+(i1/4)%(imgData.width), 
                apex[1]+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }
    pathArrR.sort(function(a, b){if (Math.abs(a[0] - b[0])>0.1) {return a[0] - b[0]} else if (a[0]<center[0]) {return a[1] - b[1]} else {return b[1] - a[1]} });
    pathArrG.sort(function(a, b){if (Math.abs(b[1] - a[1])>0.1) {return b[1] - a[1]} else {return b[0] - a[0]}});
    pathArrB.sort(function(a, b){if (Math.abs(a[1] - b[1])>0.1) {return a[1] - b[1]} else {return b[0] - a[0]}});
    
    pathArr=Array.from(pathArrR).concat(Array.from(pathArrG)).concat(Array.from(pathArrB));
    //circle();
}

function getSailorPathArr(start, boxes, halfbox) {
    pathArrR=[];
    pathArrG=[];
    pathArrB=[];
    // start=[center[0]/2, center[1]];
    // boxes=4;
    // halfbox=center[1]/(2*boxes);
    //pathArrR.push([bleft[0],bleft[1]]) ;

    for (i1=0; i1< imgData.data.length; i1=i1+1) {
        if(imgData.data[i1]!=0) {
            if (i1%4==0) {
                pathArrR.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%4==1) {
                pathArrG.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
            if (i1%4==2) {
                pathArrB.push([start[0]+(i1/4)%(imgData.width), 
                start[1]-2*halfbox+Math.floor((i1/4)/(imgData.width))]);
            }
        }
    }
    pathArrR.sort(function(a, b){return a[0] - b[0]});
    pathArrG.sort(function(a, b){if (Math.abs(b[0] - a[0])>0.1) {return b[0] - a[0]} else {return b[1]-a[1]}});
    pathArrB.sort(function(a, b){return a[0] - b[0]});

    function sieve(currentValue, index, arr) {
        if (index%4==0) {
            return currentValue;
        }
    }

    pathArrR_f=pathArrR.filter(sieve);
    pathArrG_f=pathArrG.filter(sieve);
    pathArrB_f=pathArrB.filter(sieve);
    
    pathArr=Array.from(pathArrB_f).concat(Array.from(pathArrG_f)).concat(Array.from(pathArrR_f));
    //circle();



}

// Update ball position and bounce logic
function updateBall(ball, pathArr) {

    if (ball.pathindx<pathArr.length-1) {
        ball.pathindx+=1;
    } else {
        ball.pathindx=0;
        ball.color = getRandomColor();
    }
    
    ball.x = pathArr[ball.pathindx][0];
    ball.y = pathArr[ball.pathindx][1];

    // Bounce off left/right walls
    if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx *= -1;
        ball.color = getRandomColor(); // change color on bounce
    }

    // Bounce off top/bottom walls
    if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
        ball.dy *= -1;
        ball.color = getRandomColor(); // change color on bounce
    }
}

// Animation loop
function animate() {
    // Draw semi-transparent background for trailing effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawBall(ball1);
    updateBall(ball1, pathArr);
    if (ball2.x==null) {
        ball2.pathindx = parseInt(Math.random()*pathArr.length);
        ball3.pathindx = parseInt(Math.random()*pathArr.length);
    }
    
    drawBall(ball2);
    updateBall(ball2, pathArr);
    
    drawBall(ball3);
    updateBall(ball3, pathArr);
    drawBall(ball4);
    updateBall(ball4, pathArr);

    requestAnimationFrame(animate);
}

// Start animation
window.setTimeout(animate, 1000);


</script>
</body>
</html>

